2.6 Calling conventionsn 
__stdcall 
	- cleans up stack by popping arguments from the stack WITHIN the function (the caller)

__cdecl
	- adds cleanup code to pop the argumennts from the stack AFTER the call to the function, in this case
	  the caller is resp. for cleanup.

Stdcall bins are smaller than cdecl because it doesnn't need the stack cleanup
code inserted every time a function is called. 
	- if same function used 10X with stdcall, the stack cleanup code occurs 1 time
	  in our code, in the function itiself. 
    - in cdecl, the cleanup coode would be added 10X to each instance immediatelly after CALL instr.

__fastcall
	- stack cleanup occurs inside the callee, but some params are passed to general registers
	  instead of being passed via stack before entering function
	- makes less use of stack.

Window32 API functions
	- use __stdcall
	- amount of mem nneeded for the arguments of each call is predefined, so
	  the function knows how much space to clean up before exit

__stdcall/__fastcall sample, assume that for fastcall, 2 of the parameters were pushed onto the stack
=====
push a
push b
call somefuncn
test eax,eax
JE _somewhere
=====

Inside somefunc we'd see function epilogue
====
mov esp, ebp
pop ebp
ret 8 < - Clean up stack from parameters a and b

__cdecl
=======
push a 
push b
call somefunc
add esp, 8 <--in this case, caller cleans the stack; remember stack grows down,
	- so if i have ESP == 22 , EBP = 40, 40-22 = 18 = stack size
	- then add esp, 8 -> ESP == 30, EBP = 40, 40-30 = 10 = stack size
test eax, eax
JE _somewhere
========
From inside somefunc at the epilog we would see this
=====
mov esp, ebp
pop ebp
ret

2.7 -- reading EIP; simple trick
We don't have direct access to EIP but we might wantn to know address of next instruction. 
What we can do is create an instruction that returns in EAX or some other register we have direct
access to, the value of EIP

Ex
====
GetEIP proc
mov eax, dword ptr ss:[esp]
ret
GetEIP endp
====

Or this
====
Call __getEip
__getEIP: pop eax

In the first case, we call the GetEIP func which moves the return naddress (next instruction)
into EAX;

In the next case, we jsut "call" the next instruction and pop to eax the return address, which 
will put the address of the previous insntruction executed (pop eax) into EAX, thus we 
can nlocate other parts of our code in memory, by simply adding or subtracting a value
from the result.

This is widely used by relocatable code.
It can be injected anywhere in nsource or in memory, just like shellcode.


Necessary theory 3

3.2 Heaps
DEF: memory areas dynamically allocated at runtime; store data that doesn't have
a fixed size or can't fit in stack.

Case: reading files into memory; we probably won't know exact size of every file 
that's loaded; want to optimize mem usage. Enter dynamic mem allocation.

3.3 Handles
DEF: references to various resources to control access ; read/write/etc
Windows: In order to access a file, need to create a handle to the file using WinAPII,
like CreateFiile API

3.4 Exceptions
2 Types
	- hardware
	- software

Hardware
	- bad sequence of instructions; division by 0, access invalid memory locaiton
	- initiated by CPU
	- wiindows recognizes h/w exceptions and maps them to constants/codes

Software
	- generated by app
	- Winndows implements Structured Exception Handling (SEH) for apps to handle
	  both hw/sw exceptionsn.

ADD ESP 4
	- this adds 4 bytes to the stack , recall that each "index" in a memory location is 1 byte
user@box:~/Downloads$ hexdump -C test 
           0  1  2  3  4  5  6  7   8  9 10 11 12 13 14 15
00000000  54 48 49 53 49 53 41 4c  4c 4f 4e 45 57 4f 52 44  |THISISALLONEWORD|
00000010  0a                                                |.|
00000011

3.5 Basic Windows Ring3 Internal Structures
- Looking at "userland" (RING3) Structures.
-THREAD_ENVIRONMENT_BLOCK (TEB)
  - address of top/bottom of current thread stack
  - thread ID 
  - ID of process thread belongns too
  - Error code of most recent error during thread exec.
  - Addr of Thread Local Storage (TLS)
  - Addr of PROCESS_ENVIRONMENTN_BLOCK (PEB)

-PEB
  - Image of the base process
  - PEB_LDR_DATA : Addr of the loader data structure; has pointers to lists
    regarding nthe modules loaded by the process
  - NtGlobalFlag value
  - Major/Minor versions of the Windows OS
  - Num of procoessors available
  - BeingDebugged flag
  - obvs: some info can be used for debugger detection(NtGlobalFlag & BeingDebugged)

- CONTEXT structure
  - used by system to track alll neces. CPU state info for a given thread
    under execution during internal ops.
  - Stores values of REGs needed to continue execution of the thread from the
    right virt address in case an event (e.g. hw/sw exception) occurs.

3.6 - Windws APIs 
  - == Ring3 OS functions.. 
  - COMM. PATH from the app to the OS.
  - Functional Categories
    1. Administration andn MGMT
    2. Diagnostics 
    3. Graphiics and Multimedia
    4. System Services
    5. Windows User Interface

3.7 Types of Reversing tools
  - hexeditor
  - decompiler
  - Disassembler
  - Debuggers: User or Kernel???
    - Ring0 (kernel mode)  or Ring3 (user mode)
    - Anti-Reversing (AR)
    - Kernel mode debuggers are more powerful since they aren't seen by most
      anti-reversing efforts. i.e. If i try to detect debugging reversing with
      a Ring3 api, i'm likely to miss debugging/reversing at ring0
    - Ring3 debuggers are easily deteted by AR but this is an advantage in
      that it allows RE's to study the AR techniques and learn about OS.
    - Ring3 debuggers are used most of the time, and are USER FRIENDLY
  - System Monitoring Tools
    - sysmon
  - Windows API Monitoring tools
    - hook APIs used by the process being monitored

4. - Virtual Addresses / Relative Virtual Addresses / Offsets / PE Format
4.2 - VA/RVA/Offset
  - CRITICAL to undnerstand how these are interconnected and how to use 1 to
    calculate the other.
  - Apps DO NOT directly access phys. mem, only virtual mem. Mem addresses 
    referenced by an app are VAs.
  - This allows an app to occupy dynamic locations of physical memory; i.e.
    it doesn't have to be all in one continous spot.
  - RVA == difference between two VA's nand refers to the highest one.
  - EXAMPLE
    - VA_1 = 0x00400000
    - VA_2 = 0x00401000
    - RVA of VA_2 = VA_2 -VA_1 = 0x000001000
  - Offsets
    - when discussing offsets we USU. refer to physical memory, a phys. file on
      disk, or where we treat data s raw data
    - OFFSET == The distance between two bytes, for example, inside a file,
      usually starting at the beginning ofo a file.

4.2.1 - WHY?
  - Patching at runtime is only temporary (e.g. to disable an AR triick)
  - Being able to calculate offset of a given byte in the file with VA/RVA 
    can allow us to patch it permanently.


4.3 PE Format
  - MS-DOS HEader
    - at start of every PE.
    - First bytes are traditional MS-DOS Header; IMAGE_DOS_HEADER; two values
      - e_magic: a WORD (16-bit) value == 0x5A4D == MZ in ascii == IMAGE_DOSO_SIGNATURE
      - e_lfanew : at offset 3ch; contnaiins file offset of the start of the PE header.
        AKA IMAGE_NT_HEADERS structure. 

  - IMAGE_NT_HEADERS Structure (PE header)
    - a struct of structures
    - typedef struct _IMAGE_NT_HEADERS {
        DWORD                     Signature;
        IMAGE_FILE_HEADER         FileHeader; 
        IMAGE_OPTIONAL_HEADER     OptionalHeader;
        IMAGE_NT_HEADERS;         *PIMAGE_NT_HEADERS;
      }
    - Signature is 50450000h ("PE\0\0" in ASCII)

  - IMAGE_FILE_HEADER Structure
    - contains info about executable characteristics: ARCH, number of sections,
      e.g. .text, .data. 
    - Contains member var with size value of IMAGE_OPTIONAL_HEADER called
      SizeOfOptionalHeader (value most be set to E0h/0xE0)
      - IMAGE_OPTIONAL_HEADER is requred for every structure even tho it's "optional"
    - Characterstics var defines stuff like type of exe i.e .exe or .dll
    - typedef struct _IMAGE_NT_HEADERS {
        WORD    Machine;
        WORD    NumberOfSections;
        DWORD   TimeDateStamp;
        DWORD   PointerToSymbolTable;
        DWORD   NumberOfSymbols;
        WORD    SizeOfOptionalHeader;
        WORD    Characteristics;
      } IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;
      
  - IMAGE_OPTIONAL_HEADER
    - Recall this is NOT OPTIONAL
    - typedef struct _IMAGE_OPTIONAL_HEADER {
        WORD                  Magic;
        BYTE                  MajorLinkerVersion;
        BYTE                  MinoorLinkerVersion;
        DWORD                 SizeOfCode;
        DWORD                 SizeOfInitializedData;
        DWORD                 SizeOfUninitializedData;
        DWORD                 AddressOfEntryPoint;
        DWORD                 BaseOfCode; 
        DWORD                 BaseOfData;
        DWORD                 ImageBase;
        DWORD                 SectionAlignment;
        DWORD                 FileAlignment;
        WORD                  MajorOperatingSystemVersion;
        WORD                  MinorOperatingSystemVersion;
        WORD                  MajorImageVersion;
        WORD                  MinorImageVersion;
        WORD                  MajorSubsystemVersion;
        WORD                  MinorSubsystemVersion;
        DWORD                 Win32VersionValue;
        DWORD                 SizeOfIimage;
        DWORD                 SizeOfHeaders;
        DWORD                 CheckSum;
        WORD                  Subsystem;
        WORD                  DllCharacteristics;
        DWORD                 SizeOfStackReserve;
        DWORD                 SizeOfStackCommit;
        DWORD                 SizeOfHeapReserve;
        DWORD                 SizeOfHeapCommit;
        DWORD                 LoaderFlags;
        DWORD                 NumberOfRvaAndSizes;
        IMAGE_DATA_DIRECTORY  DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; 
      } IMAGE_OPTIONAL_HEADER, *PIMAGE_OPTIONAL_HEADER;
    - Magic member var defines if PE is 32/64 bit
    - AddressOfEntry hodls the RVA of the EntryPoint (EP) of the module; the RVA
      of the address inside the module itself which is the location of the first
      instruction to be executed.
      
5. String Refs & Basic Patching
  - KEY: Finding the allgorithms we want.

5.2 - String nrefs
  - using string refs we may be able to locate pieces of code.
  - String ref == asm instruction referring to memory location where
    a string is stored.

5.4 - Analyzing the RE5 file
  - When we first load the binary into ollydbg, we land at the entry pint, 0x004020D0

=====
EAX 7789EF2A kernel32.BaseThreadInitThunk
ECX 00000000
EDX 004020D0 RE_Cours.<ModuleEntryPoint>
EBX 7FFDF000
ESP 0012FF8C
EBP 0012FF94
ESI 00000000
EDI 00000000
EIP 004020D0 RE_Cours.<ModuleEntryPoint>            <<<<---------------- ENTRY POINT
C 0  ES 0023 32bit 0(FFFFFFFF)
P 1  CS 001B 32bit 0(FFFFFFFF)
A 0  SS 0023 32bit 0(FFFFFFFF)
Z 1  DS 0023 32bit 0(FFFFFFFF)
S 0  FS 003B 32bit 7FFDE000(FFF)
T 0  GS 0000 NULL
D 0
O 0  LastErr ERROR_ENVVAR_NOT_FOUND (000000CB)
EFL 00000246 (NO,NB,E,BE,NS,PE,GE,LE)
ST0 empty 0.0
ST1 empty 0.0
ST2 empty 0.0
ST3 empty 0.0
ST4 empty 0.0
ST5 empty 0.0
ST6 empty 0.0
ST7 empty 0.0
               3 2 1 0      E S P U O Z D I
FST 0000  Cond 0 0 0 0  Err 0 0 0 0 0 0 0 0  (GT)
FCW 027F  Prec NEAR,53  Mask    1 1 1 1 1 1
======
  - Note at the prompt, whatever we enter keeps giving us "This code is invalid"
  - That string gives us a clue of what to search for, because it can lead us to 
    the location in the code where the decision is made to call that string.
  - Right click CPU-Mainthread window -> Search For -> Search for all referenced text strnigs
  -  Therein we find a reference to our message "This code is Invalid
===
Text strings referenced in RE_Cours:.text, item 16
 Address=00402E9E
 Disassembly=MOV DWORD PTR SS:[EBP-44],RE_Cours.0063B2DC
 Text string=ASCII "This code is invalid!!!"
===
  - The instruction referencing our sring is at 00402E9E; if we double click
    this address we will be taken there
  - The logic happens a few lines above this address

===
00402E64  |. EB 05          JMP SHORT RE_Cours.00402E6B
00402E66  |> B8 A8B26300    MOV EAX,RE_Cours.0063B2A8
00402E6B  |> 50             PUSH EAX
00402E6C  |. E8 F3942200    CALL RE_Cours.0062C364
00402E71  |. 83C4 08        ADD ESP,8
00402E74  |. 85C0           TEST EAX,EAX
                                                                         |--------------------------------
00402E76  |. 75 1F          JNZ SHORT RE_Cours.00402E97 <---------------- SENDS THE CONTROL to one instr|
                                                                         | above our string reference    |
                                                                         --------------------------------
00402E78  |. C745 C8 ACB263>MOV DWORD PTR SS:[EBP-38],RE_Cours.0063B>;  ASCII "Congratulations!"
00402E7F  |. C745 C4 BDB263>MOV DWORD PTR SS:[EBP-3C],RE_Cours.0063B>;  ASCII "Your code is valid!!!"
00402E86  |. 6A 40          PUSH 40                                  ; /Style = MB_OK|MB_ICONASTERISK|MB_APPLMODAL
00402E88  |. FF75 C8        PUSH DWORD PTR SS:[EBP-38]               ; |Title
00402E8B  |. FF75 C4        PUSH DWORD PTR SS:[EBP-3C]               ; |Text
00402E8E  |. 6A 00          PUSH 0                                   ; |hOwner = NULL
00402E90  |. E8 8F6C2300    CALL <JMP.&USER32.MessageBoxA>           ; \MessageBoxA
00402E95  |. EB 1D          JMP SHORT RE_Cours.00402EB4

                        |||||||||| JNZ Short above lands at the line below ||||||||||||||||||||
00402E97  |> C745 C0 D3B263>MOV DWORD PTR SS:[EBP-40],RE_Cours.0063B>;  ASCII "Warning!"
00402E9E  |. C745 BC DCB263>MOV DWORD PTR SS:[EBP-44],RE_Cours.0063B>;  ASCII "This code is invalid!!!"
===
  - What really happens
    - Program calls a function at 402E6C, RE_Course.0062C364, which will return
      a value to EAX, after the function returns, then stack is cleaned ( add ESP, 8)
      and then the value in EAX is tested; if it's a non zero number, if it's NOT
      zero, i.e JNZ, the jump is taken, otherwise we would hit line 402E78
  - Basic memory patching
    - To bypass this check, we can patch the binary; the OPCODE (instruction) has the hex 
      value of 75 1F as seen below
      ===
      00402E76  |. 75 1F          JNZ SHORT RE_Cours.00402E97
      ===
    - Note the label is not needed, the above is the same as 
      ===
      00402E76  |. 75 1F          JNZ SHORT 00402E97
      ===
    - Breakdown of the values
      - 00402E97  == The VA of the first byte (0x75) of the instruction
      - 0x75      == Opcode of the JNZ insx
      - 0x1F      == The number of bytes to "jump" by redirecting the eip
      - this can be confirmed with some addition
      - THe JNZ instruction ends at 0x402E77 (the number of bytes to skip, 1F)
        - 0x402E77 + 1F == 402E96, meaning everything up to and including 402E96
          should be "jumped" meaning the next instruction will be 402E97!
    - 3 general ways to patch a conditional jump
      - NOP out the instruction (since it's two bytes, it would be replaced with
        two NOPS, or 0x90 ox 90, leaving us with this
        ===
        0x00402E76  9090    NOP NOP
        ===
        - If we right click the line -> binary -> edit, we can change 75 1F to 90 90
        then click save and keep size
        - Now when we run the binary, we get "Your code is valid!"
        - We can right click each 90 and select undo selection to continue other patching options
      - FLIP THE LOGIC
        - Since this is JNZ, inverted logic would be JZ, i.e jump if zero, the opcode for this is 0x74
        - To do this, select insx -> right click -> assemble
        - This leaves us with
          ===
          00402E76     74 1F          JE SHORT RE_Cours.00402E97
          ===
        - Now we can run (or enter the code again since the program is still running)
        - Undo selection to restore the instruciton and we'll see the third case
      - ZERO OUT THE OPERAND
        - The JNZ struction has to be told how many bytes to skip, so if it's told 00
          it will skip zero bytes and have the same effect as the above two insx.
        - Right click -> binary -> edit , change 1F to 00
        - Submit a code again, and note we've achieved the same effect.

5.4.6 - Executable patching in ollydbg
  - The above samples worked but were only in-memory patches, meaning they only
    worked on the running sample.
  - To achieve persistence, we'd have to write these to the binary itself.
  - To do this
    1. make your desired modification as we did previously
    2. Right click the edited byes
    3. Select "Copy to Executable" 
    4. Click "Selection" or all modifications if this was the only modification

5.4.7 - VA --> OFFSET manual calculation
  - To permanently modify the bytes, we'd have to know the offset inside the phys file.
  - Olly does this automatically, but we should know how to do this manually. 
  - To patch the bytes , we need to now their offsets.
  - We can find such info in the header
    1. Hit alt+M in olly to see how the exee is mapped inmemory with it's modules
    2. Recall the address of the byte we want to patch; for option 3, this would
       be 0x402E77, or 1f, which we're changing to 00
    3. In the mapped memory view, you might notice that this insx address falls into
      the .text section which starts at 401000, and has a size of 23A000, meaning
      that everythong from 0x401000 -- 0x63B000 (exclusive) is in the .text section
    4. Note that the image base (with PE Header) is at 0x00400000 (default for windows PE)
    5. Choose the first line in the memory map ( one with the PE header, i.e. 0x400000)
      right click -> Dump in CPU
    6. In the data window (bottom left, typical hexdump) right click -> Special -> PE Header.
      This dumps the PE header in a readable format in the data window
      ===
      00400000   4D 5A        ASCII "MZ"           ; DOS EXE Signature
      00400002   5000         DW 0050              ;  DOS_PartPag = 50 (80.)
      00400004   0200         DW 0002              ;  DOS_PageCnt = 2
      00400006   0000         DW 0000              ;  DOS_ReloCnt = 0
      00400008   0400         DW 0004              ;  DOS_HdrSize = 4
      0040000A   0F00         DW 000F              ;  DOS_MinMem = F (15.)
      0040000C   FFFF         DW FFFF              ;  DOS_MaxMem = FFFF (65535.)
      0040000E   0000         DW 0000              ;  DOS_ReloSS = 0
      00400010   B800         DW 00B8              ;  DOS_ExeSP = B8
      00400012   0000         DW 0000              ;  DOS_ChkSum = 0
      00400014   0000         DW 0000              ;  DOS_ExeIP = 0
      00400016   0000         DW 0000              ;  DOS_ReloCS = 0
      00400018   4000         DW 0040              ;  DOS_TablOff = 40
      0040001A   1A00         DW 001A              ;  DOS_Overlay = 1A
      ===
    7. Now we need to locate thee line that mentions ".text"; this is here
      ===
      004002F8   2E 74 65 78 >ASCII ".text"        ; SECTION
      00400300   00A02300     DD 0023A000          ;  VirtualSize = 23A000 (2334720.)
      00400304   00100000     DD 00001000          ;  VirtualAddress = 1000
      00400308   00922300     DD 00239200          ;  SizeOfRawData = 239200 (2331136.)
      0040030C   00060000     DD 00000600          ;  PointerToRawData = 600
      00400310   00000000     DD 00000000          ;  PointerToRelocations = 0
      00400314   00000000     DD 00000000          ;  PointerToLineNumbers = 0
      00400318   0000         DW 0000              ;  NumberOfRelocations = 0
      0040031A   0000         DW 0000              ;  NumberOfLineNumbers = 0
      0040031C   20000060     DD 60000020          ;  Characteristics = CODE|EXECUTE|READ
      ===
      - This is the IMAGE_SECTION_HEADER structure previously mentioned. 
      - There may be cases where multiple sections have the sane name, but we
        can identify them by the value of their RVA
      - VirtualSize, is the size of the section in memory
      - VirtualAddress: the RVA of the section in memory, not the VirtualAddress
      - SizeofRawData : size of the section in the file
      - PointerToRawData : starting offset of the section in the file
    8. This gives us all the data that we need
      - byte-offset = Byte_VA - (image-base+Section-RVA)+PointerToRawData)
      - 0x402E77-(0x400000+0x1000)+0x600
        = 0x402E77-0x401000+0x600
        = 0x402E77-0x400A00
        = 0x2477
      - So in a hex editor we should be able to find this byte at the given offset
        - Bingo
        ===
                    00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
        0x00002460  05 8B 45 FC EB 05 B8 A8 B2 63 00 50 E8 F3 94 22 
        0x00002470  00 83 C4 08 85 C0 75 1F
        ===
        And sure enough, 2477 == 1F, which we can change to 00

5.4.8 - Conclusion
  - This method works for this, but won't always works.
  - What happens when strings are encrypted? 


