2.6 Calling conventionsn 
__stdcall 
	- cleans up stack by popping arguments from the stack WITHIN the function (the caller)

__cdecl
	- adds cleanup code to pop the argumennts from the stack AFTER the call to the function, in this case
	  the caller is resp. for cleanup.

Stdcall bins are smaller than cdecl because it doesnn't need the stack cleanup
code inserted every time a function is called. 
	- if same function used 10X with stdcall, the stack cleanup code occurs 1 time
	  in our code, in the function itiself. 
    - in cdecl, the cleanup coode would be added 10X to each instance immediatelly after CALL instr.

__fastcall
	- stack cleanup occurs inside the callee, but some params are passed to general registers
	  instead of being passed via stack before entering function
	- makes less use of stack.

Window32 API functions
	- use __stdcall
	- amount of mem nneeded for the arguments of each call is predefined, so
	  the function knows how much space to clean up before exit

__stdcall/__fastcall sample, assume that for fastcall, 2 of the parameters were pushed onto the stack
=====
push a
push b
call somefuncn
test eax,eax
JE _somewhere
=====

Inside somefunc we'd see function epilogue
====
mov esp, ebp
pop ebp
ret 8 < - Clean up stack from parameters a and b

__cdecl
=======
push a 
push b
call somefunc
add esp, 8 <--in this case, caller cleans the stack; remember stack grows down,
	- so if i have ESP == 22 , EBP = 40, 40-22 = 18 = stack size
	- then add esp, 8 -> ESP == 30, EBP = 40, 40-30 = 10 = stack size
test eax, eax
JE _somewhere
========
From inside somefunc at the epilog we would see this
=====
mov esp, ebp
pop ebp
ret

2.7 -- reading EIP; simple trick
We don't have direct access to EIP but we might wantn to know address of next instruction. 
What we can do is create an instruction that returns in EAX or some other register we have direct
access to, the value of EIP

Ex
====
GetEIP proc
mov eax, dword ptr ss:[esp]
ret
GetEIP endp
====

Or this
====
Call __getEip
__getEIP: pop eax

In the first case, we call the GetEIP func which moves the return naddress (next instruction)
into EAX;

In the next case, we jsut "call" the next instruction and pop to eax the return address, which 
will put the address of the previous insntruction executed (pop eax) into EAX, thus we 
can nlocate other parts of our code in memory, by simply adding or subtracting a value
from the result.

This is widely used by relocatable code.
It can be injected anywhere in nsource or in memory, just like shellcode.


Necessary theory 3

3.2 Heaps
DEF: memory areas dynamically allocated at runtime; store data that doesn't have
a fixed size or can't fit in stack.

Case: reading files into memory; we probably won't know exact size of every file 
that's loaded; want to optimize mem usage. Enter dynamic mem allocation.

3.3 Handles
DEF: references to various resources to control access ; read/write/etc
Windows: In order to access a file, need to create a handle to the file using WinAPII,
like CreateFiile API

3.4 Exceptions
2 Types
	- hardware
	- software

Hardware
	- bad sequence of instructions; division by 0, access invalid memory locaiton
	- initiated by CPU
	- wiindows recognizes h/w exceptions and maps them to constants/codes

Software
	- generated by app
	- Winndows implements Structured Exception Handling (SEH) for apps to handle
	  both hw/sw exceptionsn.

ADD ESP 4
	- this adds 4 bytes to the stack , recall that each "index" in a memory location is 1 byte
user@box:~/Downloads$ hexdump -C test 
           0  1  2  3  4  5  6  7   8  9 10 11 12 13 14 15
00000000  54 48 49 53 49 53 41 4c  4c 4f 4e 45 57 4f 52 44  |THISISALLONEWORD|
00000010  0a                                                |.|
00000011


