2.6 Calling conventionsn 
__stdcall 
	- cleans up stack by popping arguments from the stack WITHIN the function (the caller)

__cdecl
	- adds cleanup code to pop the argumennts from the stack AFTER the call to the function, in this case
	  the caller is resp. for cleanup.

Stdcall bins are smaller than cdecl because it doesnn't need the stack cleanup
code inserted every time a function is called. 
	- if same function used 10X with stdcall, the stack cleanup code occurs 1 time
	  in our code, in the function itiself. 
    - in cdecl, the cleanup coode would be added 10X to each instance immediatelly after CALL instr.

__fastcall
	- stack cleanup occurs inside the callee, but some params are passed to general registers
	  instead of being passed via stack before entering function
	- makes less use of stack.

Window32 API functions
	- use __stdcall
	- amount of mem nneeded for the arguments of each call is predefined, so
	  the function knows how much space to clean up before exit

__stdcall/__fastcall sample, assume that for fastcall, 2 of the parameters were pushed onto the stack
=====
push a
push b
call somefuncn
test eax,eax
JE _somewhere
=====

Inside somefunc we'd see function epilogue
====
mov esp, ebp
pop ebp
ret 8 < - Clean up stack from parameters a and b

__cdecl
=======
push a 
push b
call somefunc
add esp, 8 <--in this case, caller cleans the stack; remember stack grows down,
	- so if i have ESP == 22 , EBP = 40, 40-22 = 18 = stack size
	- then add esp, 8 -> ESP == 30, EBP = 40, 40-30 = 10 = stack size
test eax, eax
JE _somewhere
========
From inside somefunc at the epilog we would see this
=====
mov esp, ebp
pop ebp
ret

2.7 -- reading EIP; simple trick
We don't have direct access to EIP but we might wantn to know address of next instruction. 
What we can do is create an instruction that returns in EAX or some other register we have direct
access to, the value of EIP

Ex
====
GetEIP proc
mov eax, dword ptr ss:[esp]
ret
GetEIP endp
====

Or this
====
Call __getEip
__getEIP: pop eax

In the first case, we call the GetEIP func which moves the return naddress (next instruction)
into EAX;

In the next case, we jsut "call" the next instruction and pop to eax the return address, which 
will put the address of the previous insntruction executed (pop eax) into EAX, thus we 
can nlocate other parts of our code in memory, by simply adding or subtracting a value
from the result.

This is widely used by relocatable code.
It can be injected anywhere in nsource or in memory, just like shellcode.


Necessary theory 3

3.2 Heaps
DEF: memory areas dynamically allocated at runtime; store data that doesn't have
a fixed size or can't fit in stack.

Case: reading files into memory; we probably won't know exact size of every file 
that's loaded; want to optimize mem usage. Enter dynamic mem allocation.

3.3 Handles
DEF: references to various resources to control access ; read/write/etc
Windows: In order to access a file, need to create a handle to the file using WinAPII,
like CreateFiile API

3.4 Exceptions
2 Types
	- hardware
	- software

Hardware
	- bad sequence of instructions; division by 0, access invalid memory locaiton
	- initiated by CPU
	- wiindows recognizes h/w exceptions and maps them to constants/codes

Software
	- generated by app
	- Winndows implements Structured Exception Handling (SEH) for apps to handle
	  both hw/sw exceptionsn.

ADD ESP 4
	- this adds 4 bytes to the stack , recall that each "index" in a memory location is 1 byte
user@box:~/Downloads$ hexdump -C test 
           0  1  2  3  4  5  6  7   8  9 10 11 12 13 14 15
00000000  54 48 49 53 49 53 41 4c  4c 4f 4e 45 57 4f 52 44  |THISISALLONEWORD|
00000010  0a                                                |.|
00000011

3.5 Basic Windows Ring3 Internal Structures
- Looking at "userland" (RING3) Structures.
-THREAD_ENVIRONMENT_BLOCK (TEB)
  - address of top/bottom of current thread stack
  - thread ID 
  - ID of process thread belongns too
  - Error code of most recent error during thread exec.
  - Addr of Thread Local Storage (TLS)
  - Addr of PROCESS_ENVIRONMENTN_BLOCK (PEB)

-PEB
  - Image of the base process
  - PEB_LDR_DATA : Addr of the loader data structure; has pointers to lists
    regarding nthe modules loaded by the process
  - NtGlobalFlag value
  - Major/Minor versions of the Windows OS
  - Num of procoessors available
  - BeingDebugged flag
  - obvs: some info can be used for debugger detection(NtGlobalFlag & BeingDebugged)

- CONTEXT structure
  - used by system to track alll neces. CPU state info for a given thread
    under execution during internal ops.
  - Stores values of REGs needed to continue execution of the thread from the
    right virt address in case an event (e.g. hw/sw exception) occurs.

3.6 - Windws APIs 
  - == Ring3 OS functions.. 
  - COMM. PATH from the app to the OS.
  - Functional Categories
    1. Administration andn MGMT
    2. Diagnostics 
    3. Graphiics and Multimedia
    4. System Services
    5. Windows User Interface

3.7 Types of Reversing tools
  - hexeditor
  - decompiler
  - Disassembler
  - Debuggers: User or Kernel???
    - Ring0 (kernel mode)  or Ring3 (user mode)
    - Anti-Reversing (AR)
    - Kernel mode debuggers are more powerful since they aren't seen by most
      anti-reversing efforts. i.e. If i try to detect debugging reversing with
      a Ring3 api, i'm likely to miss debugging/reversing at ring0
    - Ring3 debuggers are easily deteted by AR but this is an advantage in
      that it allows RE's to study the AR techniques and learn about OS.
    - Ring3 debuggers are used most of the time, and are USER FRIENDLY
  - System Monitoring Tools
    - sysmon
  - Windows API Monitoring tools
    - hook APIs used by the process being monitored

4. - Virtual Addresses / Relative Virtual Addresses / Offsets / PE Format
4.2 - VA/RVA/Offset
  - CRITICAL to undnerstand how these are interconnected and how to use 1 to
    calculate the other.
  - Apps DO NOT directly access phys. mem, only virtual mem. Mem addresses 
    referenced by an app are VAs.
  - This allows an app to occupy dynamic locations of physical memory; i.e.
    it doesn't have to be all in one continous spot.
  - RVA == difference between two VA's nand refers to the highest one.
  - EXAMPLE
    - VA_1 = 0x00400000
    - VA_2 = 0x00401000
    - RVA of VA_2 = VA_2 -VA_1 = 0x000001000
  - Offsets
    - when discussing offsets we USU. refer to physical memory, a phys. file on
      disk, or where we treat data s raw data
    - OFFSET == The distance between two bytes, for example, inside a file,
      usually starting at the beginning ofo a file.

4.2.1 - WHY?
  - Patching at runtime is only temporary (e.g. to disable an AR triick)
  - Being able to calculate offset of a given byte in the file with VA/RVA 
    can allow us to patch it permanently.


4.3 PE Format
  - MS-DOS HEader
    - at start of every PE.
    - First bytes are traditional MS-DOS Header; IMAGE_DOS_HEADER; two values
      - e_magic: a WORD (16-bit) value == 0x5A4D == MZ in ascii == IMAGE_DOSO_SIGNATURE
      - e_lfanew : at offset 3ch; contnaiins file offset of the start of the PE header.
        AKA IMAGE_NT_HEADERS structure. 

  - IMAGE_NT_HEADERS Structure (PE header)
    - a struct of structures
    - typedef struct _IMAGE_NT_HEADERS {
        DWORD                     Signature;
        IMAGE_FILE_HEADER         FileHeader; 
        IMAGE_OPTIONAL_HEADER     OptionalHeader;
        IMAGE_NT_HEADERS;         *PIMAGE_NT_HEADERS;
      }
    - Signature is 50450000h ("PE\0\0" in ASCII)

  - IMAGE_FILE_HEADER Structure
    - contains info about executable characteristics: ARCH, number of sections,
      e.g. .text, .data. 
    - Contains member var with size value of IMAGE_OPTIONAL_HEADER called
      SizeOfOptionalHeader (value most be set to E0h/0xE0)
      - IMAGE_OPTIONAL_HEADER is requred for every structure even tho it's "optional"
    - Characterstics var defines stuff like type of exe i.e .exe or .dll
    - typedef struct _IMAGE_NT_HEADERS {
        WORD    Machine;
        WORD    NumberOfSections;
        DWORD   TimeDateStamp;
        DWORD   PointerToSymbolTable;
        DWORD   NumberOfSymbols;
        WORD    SizeOfOptionalHeader;
        WORD    Characteristics;
      } IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;
      
  - IMAGE_OPTIONAL_HEADER
    - Recall this is NOT OPTIONAL
    - typedef struct _IMAGE_OPTIONAL_HEADER {
        WORD                  Magic;
        BYTE                  MajorLinkerVersion;
        BYTE                  MinoorLinkerVersion;
        DWORD                 SizeOfCode;
        DWORD                 SizeOfInitializedData;
        DWORD                 SizeOfUninitializedData;
        DWORD                 AddressOfEntryPoint;
        DWORD                 BaseOfCode; 
        DWORD                 BaseOfData;
        DWORD                 ImageBase;
        DWORD                 SectionAlignment;
        DWORD                 FileAlignment;
        WORD                  MajorOperatingSystemVersion;
        WORD                  MinorOperatingSystemVersion;
        WORD                  MajorImageVersion;
        WORD                  MinorImageVersion;
        WORD                  MajorSubsystemVersion;
        WORD                  MinorSubsystemVersion;
        DWORD                 Win32VersionValue;
        DWORD                 SizeOfIimage;
        DWORD                 SizeOfHeaders;
        DWORD                 CheckSum;
        WORD                  Subsystem;
        WORD                  DllCharacteristics;
        DWORD                 SizeOfStackReserve;
        DWORD                 SizeOfStackCommit;
        DWORD                 SizeOfHeapReserve;
        DWORD                 SizeOfHeapCommit;
        DWORD                 LoaderFlags;
        DWORD                 NumberOfRvaAndSizes;
        IMAGE_DATA_DIRECTORY  DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; 
      } IMAGE_OPTIONAL_HEADER, *PIMAGE_OPTIONAL_HEADER;
    - Magic member var defines if PE is 32/64 bit
    - AddressOfEntry hodls the RVA of the EntryPoint (EP) of the module; the RVA
      of the address inside the module itself which is the location of the first
      instruction to be executed.
      
5. String Refs & Basic Patching
  - KEY: Finding the allgorithms we want.

5.2 - String nrefs
  - using string refs we may be able to locate pieces of code.
  - String ref == asm instruction referring to memory location where
    a string is stored.
